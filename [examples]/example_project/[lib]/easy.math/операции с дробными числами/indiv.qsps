QSP-Game Вычисляет рациональное частное от целых чисел
args[0] - делимое
args[1] - делитель, по умолчанию = 100
args[2] - точность вычисления. 1 - до целых, 10 - до десятых, 100 - до сотых и т.д. По умолчанию, вычисляет до девятого знака после запятой.
$result - текстовое значение вида 000.000

# em.indiv
local $minus_, $res_indiv_	& !@ инициализация локальных переменных
if (args[0]<0 and args[1]>0) or (args[0]>0 and args[1]<0): $minus_='-'	& !@ если одно из чисел меньше нуля, а другое больше, результат будет отрицательным
if args[0]<0: args[0]=-args[0]	& !@ приводим к модулю
if args[1]<0: args[1]=-args[1]	& !@ приводим к модулю
if args[1]=0: args[1]=100	& !@ если делитель не задан, считается равным 100
if args[2]=0: args[2]=1000000000	& !@ по умолчанию вычисляем частное до девятого знака после запятой (максимальное значение аргумента)
args[2]=len($str(args[2]))	& !@ в args[2] записываем не круглое число, как строку разрядов, а длину этой строки, то есть число разрядов +1
!@ следующий цикл обеспечивает деление по методу `столбиком`.
loop local i,div_,rod_=0,0,0 while i<args[2] step i+=1:
	div_=args[0]/args[1]	& !@ получаем частное от деления без остатка
	rod_=args[0] mod args[1]	& !@ получаем остаток
	if i=1: $res_indiv_+='.'	& !@ если это вторая итеррация, значит пришло время ставить точку
	$res_indiv_+=$str(div_)	& !@ к результату деления добавляем строковое значение частного
	args[0]=rod_*10	& !@ умножаем остаток на 10, чтобы продолжать вычисление, и теперь это наше новое число
end
$result=$minus_+@em.dz($res_indiv_)	& !@ возвращаем результат
--- em.indiv ---------------------------------

Функция использует функцию delete_zero, она же em.dz, она же em.dz. В новой версии em.float.dz

