# QSP-Package для Sublime Text

Пакет QSP для редактора Sublime Text включает в себя подсветку синтаксиса для языка QSP, встроенный билдер, собирающий и запускающий QSP-игры из файлов-исходников, а так же наборы сниппетов, инструментов работы с проектом и другие элементы, облегчающие разработку игр на QSP.

> Если вы не имели дела с SublimeText, есть краткая пошаговая инструкция по первому запуску игры с нуля: [Краткая инструкция по установке пакета QSP для SublimeText с нуля](https://github.com/AleksVersus/JAD_for_QSP/blob/master/siaiz.md)

## Преимущества Sublime Text в сравнении с QuestGenerator 4.0.0

Всем новичкам в разработке игр на QSP я предлагаю начинать с [Quest Generator](https://wiki.qsp.org/help:qgen), так как он удобен, прост и интуитивно понятен. Пишешь локации, нажатием на кнопку запускаешь игру — тестируешь.

Тем же, кому не достаёт возможностей в Quest Generator, предлагаю воспользоваться более удобным и функциональным редактором Sublime Text.

Вот какие преимущества даёт Sublime Text с установленным в него пакетом QSP:

1. **Исходники**. Разработка игры ведётся исключительно в текстовых файлах (исходниках) формата TXT2GAM (QSPS), что позволяет:
	* Использовать системы контроля версий типа GIT на всех этапах разработки, а значит фиксировать и отслеживать все изменения, вносимые в игру и быстрее находить ошибки.
	* Вести совместную разработку игры с использованием общего репозитория на ресурсах типа GitHub.
	* Проводить поиск по отдельным папкам, файлам, или по всему проекту.
2. **Удобная модульная разработка:** то есть вы можете разбивать игру на сколь угодно большое число частей и подчастей, организовывать эти части по папкам, вкладывая папки друг в друга, или даже хранить некоторые части игры отдельно, а в нужный момент [**билдер**](#QSP-Builder-для-Sublime-Text) сам соберёт все нужные вам файлы "`.qsp`" и запустит игру в плеере по нажатию пары клавиш.
3. **Один редактор — много плееров**. Вы можете завести несколько [файлов проекта](#projectjson), каждый из которых будет ориентирован на сборку и запуск игры в определённом плеере, что позволит вам разрабатывать игру сразу под несколько плееров.
4. **Работа с файлами ресурсов**. Sublime Text из коробки умеет подсвечивать CSS, HTML и JavaScript-файлы, что позволяет работать с этими файлами в том же редакторе, в котором вы работаете над основной частью игры.
5. **Расширения**. Вы можете настроить редактор под себя, создавая собственные сниппеты, устанавливая различные вспомогательные плагины и т.д. Например, вы можете установить в Sublime Text [проверку орфографии](https://devmag.ru/sublime-text-3-spellcheck/), или Emmet, облегчающий работу с HTML.
6. **Подсветка кода**. Умеет очень многое:
	* Поскольку текст между локациями не попадает в финальную версию игры, он подсвечивается как комментарий.
	* Распознавание начала и конца локации и соответственно подсветка этих элементов.
	* Подсветка, которую умеет Quest Generator:
		* Подсветка сложных многострочных комментариев.
		* Подсветка строковых констант.
		* Подсветка числовых констант, системных переменных, операторов и функций.
		* Подсветка меток на локации
	* Подсветка вложенных выражений (подвыражений) в строках.
	* Подсветка основных синтаксических ошибок:
		* Лишний `$` перед именами числовых системных переменных или функций.
		* Отсутствие `$` перед именами текстовых системных переменных и функций.
		* Звёздочка `*` перед именем операторов, кроме `*pl`, `*p`, `*nl`, `*clr`.
		* Неверное число операндов у операций типа `+`, `-`, `*`, `<`, `>` и т.д.
		* Подсветка неправильных имён переменных типа `123build`.
		* Разрыв строки кода внутри вложенного выражения.
		* Подсветка лишнего `end`, а так же `else` и `elseif` вне конструкций условий.
		* Подсветка неправильной записи `else` и `elseif` в многострочном условии.
		* Незакрытый многострочный `act`, `loop` или `if` вызывает подсветку элемента "конец локации" или фигурной скобки, как ошибки.
		* Неправильно поставленная запятая.
		* Неверная запись оператора `local` или `set`.
		* Унарный минус перед текстовой переменной.
	* Подсветка HTML-кода в строках и фигурных скобках при вставке тегов `<qhtml>`, `</qhtml>`.
	* Подсветка конструкций неявного вызова, а так же подсветка ошибочной записи таких конструкций.
	* Подсветка команд препроцессора
	* Подсветка операторов многострочных конструкций `act`, `if`, `else`, `elseif`, `loop`, `end`. Правильная подсветка `end loop`, `end act`, `end if` - такие сочетания подсвечиваются, как отдельное ключевое слово.
7. **Автоподстановка**. Когда вы начинаете вводить ключевое слово, или уже вводившуюся ранее переменную, появляется список со словами автоподстановки. Если вы используете неявный вызов функции, редактор предложит варианты уже созданных вами локаций, начинающихся с той же буквы.
8. **Предупреждения**. Редактор предупредит вас:
	* если вы укажете для локации название, которое уже существует в проекте (пока что работает кривовато и с использованием стороннего файла).

## Формат исходных файлов

Ещё на заре появления QSP была создана утилита [TXT2GAM](https://wiki.qsp.org/help:txt2gam), которая позволяет разрабатывать игру в виде текстового файла (исходника) в любом текстовом редакторе, а потом конвертировать исходник в готовый файл игры.

Вкратце. Файлы формата TXT2GAM (исходники) — это обычные текстовые файлы, в которых код QSP записывается по определённым правилам. В данном руководстве данный формат будет называться **форматом qsps** по названию уже общепринятого расширения для подобных текстовых файлов "`.qsps`". Однако файлы формата qsps могут иметь любое иное расширение: "`.txt`", "`.start`" и т.п.

В таких файлах нет возможности работать с базовым описанием и базовыми действиями локации, а только лишь с кодом поля "Выполнить при посещении", если работу в текстовом редакторе сравнивать с работой в Quest Generator.

Типичный файл формата qsps выглядит так:

```qsp
# start
!^ в строчке выше записана метка начала локации.
! она состоит из символа решётки и названия локации.
! название можно отделять, а можно не отделять пробелом от решётки

*pl "Здесь вы видите код локации, соответствующий коду
из поля Выполнить при посещении Quest Generator'а."

! последняя строчка, это метка окончания локации
! она должна начинаться с символа - , за которым
! может находиться любой текст. Обычно это снова
! название локации, или сочетание доп символов и
! названия локации 
- start

Весь текст между локациями не попадает в игру


# вторая локация
*pl "

	В одном qsps-файле можно размещать несколько локаций,
	если это необходимо

"
--- вторая локация ---------------------------------
```

Более подробно о том, как пишутся игры на QSP в формате TXT2GAM, вы можете узнать из уроков от ELMORTEM: ["Пишем QSP-игру в текстовом редакторе"](https://wiki.qsp.org/help:txt2gam_manual).

### Кодировка

Непосредственно сами файлы QSP ("`.qsp`") имеют кодировку **utf-16le**, тогда как билдер работает исключительно с файлами в кодировке **utf-8** (без BOM-символов). Чтобы билдер собирал игру правильно, исключительно важно, чтобы все qsps-файлы вашего проекта имели кодировку **utf-8**. Будьте аккуратны при использовании спецсимволов, проверяйте соответствие в исходном и конечном файле.
## Установка пакета QSP для Sublime Text

Данная инструкция ориентирована на пользователей, которые скачают последний релиз со страницы релизов: [JAD_for_QSP/releases](https://github.com/AleksVersus/JAD_for_QSP/releases). Установка из исходников будет немного отличаться.

0. Скачайте rar-архив из последнего релиза и распакуйте в отдельную папку. В распакованном виде JAD включает в себя папку "`[disdocs]`", и её содержимое, и файл "`install.QSP.sublime-package.exe`", а так же файл текущей инструкции "`README.md`".

1. Прежде всего у вас должен быть установлен Sublime Text, желательно Sublime Text 4. Скачать его можно отсюда https://www.sublimetext.com/download.
2. Запустите файл "`install.QSP.sublime-package.exe`" и следуйте инструкциям — пакет установится автоматически.

## Состав пакета QSP для Sublime Text

### QSP-Builder

QSP-Builder (далее QBST, билдер) — это встроенный в пакет QSP плагин, который:

1. собирает из разрозненных файлов формата qsps один цельный файл игры в формате qsps;
2. конвертирует полученный qsps-файл в файл игры в формате "`.qsp`" (QSP-файл);
3. запускает указанный файл игры в стандартном или выбранном плеере QSP.

Возникающие при сборке ошибки выводятся в консоль. Консоль открывается сочетанием клавиш `Ctrl + ~`.

#### Порядок работы с проектом игры на QSP

1. Проект организуется по папкам. В корневой папке проекта должен лежать файл "`project.json`", который и содержит в себе инструкции по сборке проекта (см. раздел [**project.json**](#projectjson)).
2. Все рабочие файлы проекта пишутся в формате qsps и сохраняются с расширениями "`.qsps`", "`.qsp-txt`" или "`.txt-qsp`", предпочтительно указывать первое расширение. В качестве исключения можно указывать иные расширения, но в таком случае необходимо будет указывать пути до конкретных файлов (см. раздел "**project.json**").<br>Sublime Text по умолчанию работает с файлами кодировки UTF-8, поэтому и билдер написан под данную кодировку. Если кодировка в конечном файле игры нарушена, значит вы работаете с исходниками в кодировке отличной от UTF-8, смените кодировку исходников на UTF-8.
3. После редактирования и сохранения файлов можно выбрать один из режимов сборки:
	* "**QSP - qsp-build**" — собрать файлы согласно инструкции и сконвертировать в "`.qsp`", по умолчанию сочетание клавиш `["ctrl+alt+q"]`.
	* "**QSP - qsp-run**" — запустить стартовый файл, указанный в проекте "`project.json`", в плеере. По умолчанию сочетание клавиш `["ctrl+alt+s"]`.
	* "**QSP**" — собрать файлы согласно инструкции и запустить стартовый файл в плеере, по умолчанию сочетание клавиш `["ctrl+f5"]`.

Для примера рассмотрим проект моей игры "*fantastic battles*", которую я писал в Quest Generator.

В этом проекте пришлось разбить игру на отдельные модули для удобства разработки, и всего таких модулей получилось четыре:
* "`fb_v.0.2.qsp`" — основной файл игры, в котором подключаются все прочие файлы модулей
* "`intro.qsp`" — модуль вводных данных игры
* "`drive.qsp`" — основной движок игры
* "`bases.qsp`" — различные базы исходников для игры

Каждый из этих файлов может содержать множество локаций, поэтому для самих файлов ведутся файлы "`.qproj`", которые содержат псевдопапки. Например, в "`fb_v.0.2.qsp`" локации разбиты на псевдопапки:

-	-	"`[start]`" — стартовая локация без папки
-	"`системное меню`" — папка с локациями основного меню
	-	"`[1.0_game_start]`" — локация, запускающая игру
	-	"`[0.1_game_info]`" — локация с информацией об игре
-	"`локации места`" — папка локаций места, и собственно локации:
	-	"`[м:0]_общий_вид_локации_места`"
	-	"`[м:1]_дом`"
	-	"`[м:2]_улица`"
	-	"`место;стандартная_кухня`"
-	"`обязательные локации`" — папка стандартных локаций для этой игры
	-	"`[chest]`" — сундуки
	-	"`[death]`" — смерть
	-	"`[help]`" — помощь

Работая в редакторе типа Sublime Text, я могу не только разбить данный файл игры на отдельные файлы и разместить их по папкам, но каждую локацию писать в отдельном файле. Я могу создавать подпапки и т.д., а потом собирать те же четыре файла из разрозненных qsps-файлов.

В данном случае я бы выделил отдельную папку под каждый модуль, в том числе — под основной файл игры. Допустим так:

- "`[game]`" — папка с основным файлом игры
    - "`start.qsps`" — файл со стартовой локацией
    - "`системное меню`" — папка с локациями системного меню
        - "`sysmenu.qsps`" — обе локации системного меню в одном файле
    - "`локации места`" — папка для локаций мест, можно дополнить другими папками
        - "`стандартные места`" — папка для стандартных локаций мест
            - "`общий вид локации места.qsp-txt`" — файл с локацией "`[м:0]_общий_вид_локации_места`"
            - "`кухня.qsps`" — файл с локацией "`место;стандартная_кухня`"
		- "`дом.qsps`" — файл с локацией "`[м:1]_дом`"
		- "`улица.qsps`" — файл с локацией "`[м:2]_улица`"
	- "`обязательные локации`" — папка с файлами обязательных локаций
		- "`chests.qsps`" — файл с локацией "`[chest]`"
		- "`death and help.qsps`" — файл с локациями "`[help]`" и "`[death]`"

**Необходимо отметить**, что при сборке конечного файла из таких разрозненных файлов, к конечному файлу добавляются сначала локации из файлов, которые лежат в папках верхних уровней, затем файлы из папок нижних уровней. Таким образом локация из файла "`start.qsps`" окажется в самом верху списка локаций при создании файла "`.qsp`". Это особенно важно учитывать, если вы пользуетесь возможностями препроцессора.

#### project.json

Пример с комментариями представлен в файле ["`[disdocs]\example.json`"](https://github.com/AleksVersus/JAD_for_QSP/blob/master/%5Bdisdocs%5D/example.json).

Как видно из расширения, проект представляет собой JSON-файл. Это значит, что вся его структура состоит из JSON-объектов (в Python - это словари) и JSON-массивов (в Python - это списки). Немного более подробно о файлах формата JSON Вы можете прочитать здесь: [https://www.hostinger.ru/rukovodstva/chto-takoe-json](https://www.hostinger.ru/rukovodstva/chto-takoe-json). Пока же для краткости скажем, что JSON-объекты записываются в фигурных скобках и состоят из элементов вида ключ-значение, разделённых запятыми. Между ключом и значением обязательно ставится двоеточие, за последним элементом ни в коем случае нельзя ставить запятую. Ключ — всегда записывается с использованием кавычек, то есть это всегда строка. JSON-массивы записываются в квадратных скобках, в которых через запятую перечисляются значения. За последним значением ни в коем случае не ставится запятая. Значениями могут быть числа, строки, другие объекты и массивы.

В данном случае корневым элементом является объект, в котором присутствуют восемь элементов:

```json
"project":[],
"start":"startgame.qsp",
"converter":"C:\\Program Files\\QSP\\txt2gam.exe",
"player":"C:\\Program Files\\QSP\\qsp580\\qspgui.exe",
"save_txt2gam":"True",
"preprocessor":"Off",
"postprocessors":[],
"scans":{}
```

Обязательно нужно указать элементы "project" и "start". Если по пути "`C:\Program Files\QSP\qsp580\qspgui.exe`" не расположен плеер, нужно так же указать элемент "player". Остальные элементы указывать не обязательно.

##### project

Значением элемента "project" является массив однотипных объектов ("билдов"), в которых присутствуют следующие элементы:

```json
"build":"output_file.qsp",
"files":[],
"folders":[],
"postprocessors":[]
```

Элемент "build" содержит путь к конечному файлу "`.qsp`", который мы хотим получить.

Элементы "files" и "folders" содержат массивы однотипных объектов. И в том и в другом случае объекты содержат элементы "path", однако для "files" каждый элемент "path" содержит путь к конкретному файлу, из которого мы должны получить локации, а для "folders" каждый элемент "path" содержит путь к папке, и уже из этих папок выбираются файлы "`.qsps`", "`.qsp-txt`", "`.txt-qsp`".

```json
"files": [
	{"path":"D:\\my\\projects\\01_меню.qsp-txt"},
	{"path":"game.qsp-txt"}
],
"folders": [
	{"path": "."},
	{"path": "D:\\my\\projects\\Вопросы"},
	{"path": "projects\\Вопросы"}
]
```

Элемент "postprocessors" содержит массив путей к файлам python-скриптов относительно "`project.json`". Эти скрипты будут запускаться после того, как Билдер подготовит промежуточный текстовый файл в формате qsps, до непосредственного создания файла "`.qsp`". Таким образом можно дополнительно обработать промежуточные текстовые файлы перед окончательной сборкой. При этом каждому скрипту в качестве аргумента будет передан путь к промежуточному файлу, который внутри скрипта можно получить, используя импортированный модуль `sys`, из переменной `sys.argv[1]`. Этот параметр имеет приоритет над параметром, описанным в разделе ["postprocessors"](#postprocessors).

```json
"postprocessors": [
	".\\scripts\\renamemass.py",
	"old-lib\\simplename_for_func.py"
]
```

Из элементов "files" или "folders" должен присутствовать хотя бы один. Элемент "build" указывать обязательно. Элемент "postprocessors" можно не указывать. 

##### start

Значением элемента "start" является путь к файлу, который необходимо запускать в плеере после билда. Это не обязательно должен быть один из собранных файлов, т.е. указать можно абсолютно любой файл "`.qsp`".

```json
"start":"startgame.qsp"
```

##### converter 

Значением элемента "converter" является путь к утилите, конвертирующей файлы формата qsps в файлы "`.qsp`". В QBSP уже встроен собственный конвертер, поэтому данный элемент можно не использовать.

- Скачать утилиту TXT2GAM можно отсюда: [QSP.su/Разработчикам/TXT2GAM](https://qsp.org/index.php?option=com_content&task=view&id=52&Itemid=56)

```json
"converter":"C:\\Program Files\\QSP\\txt2gam.exe"
```

##### player

Значением элемента "player" является путь к плееру, в котором необходимо запустить игру (например, после сборки).

- Различные плееры лежат здесь: [QSP.su/Плееры](https://qsp.org/index.php?option=com_content&view=article&id=64&Itemid=87)

```json
"player":"C:\\Program Files\\QSP\\Quest Navigator\\QuestNavigator.exe"
```

##### save_txt2gam

Элемент "save_txt2gam" разрешает оставлять промежуточные файлы после сборки (т.е. рядом с каждым собранным файлом "`.qsp`" будет лежать его исходник в формате qsps с раширением "`.txt`"). Ему можно назначать значения `"True"` и `"False"`. Значением по умолчанию является `"False"`.

```json
"save_txt2gam":"True"
```

##### preprocessor

Элемент "preprocessor" позволяет включать и выключать препроцессор при сборке файлов. Подробнее см. раздел [**Препроцессор**](#препроцессор). Ему можно назначать значения `"On"`, `"Off"` и `"Hard-off"`. Значением по умолчанию является `"Off"`.

```json
"preprocessor":"On"
```

##### postprocessors

Этот элемент должен содержать массив с перечисленными в нём путями к pyhton-скриптам. Каждый скрипт из перечисленных в этом элементе будет запускаться по одному разу на каждый промежуточный файл в формате qsps проекта до непосредственного конвертирования этого файла в файл "`.qsp`". При этом, если такой параметр указан для отдельного "билда" проекта, то приоритет имеет параметр, указанный для "билда" (см. раздел [project](#project)).

Каждому файлу скрипта в момент его выполнения в качестве аргумента передаётся путь к промежуточному файлу "билда" в формате qsps. Таким образом вы можете получить доступ к этому файлу прямо из запущенного скрипта, используя переменную `sys.argv[1]`:

```python
import sys

with open(sys.argv[1], 'r', encoding="utf-8") as file:
	file_string_list=file.readlines()
```

> **Обратите внимание.** Если вы пользуетесь встроенным конвертером, промежуточные файлы записываются в кодировке "utf-8", поэтому открывать и сохранять данные файлы тоже нужно в кодировке "utf-8".
> Если вы пользуетесь внешним конвертером, промежуточные файлы будут записываться в кодировке "utf-16-le", поэтому открывать и сохранять эти файлы необходимо в той же кодировке.

Скрипты, перечисленные в этом элементе выполняются уже после выполнения команд препроцессора, вне зависимости от того, включен ли [препроцессор](#препроцессор).

> Так же **обратите внимание**, что скрипты будут вызываться в отдельных процессах python, а не подключаться в порядке импорта, поэтому значение системной переменной `__name__` в скриптах будет равно `"__main__"`.
> ***ВАЖНО!!!*** Скрипты будут запускаться в интерпретаторе Python 3.8 !!! Учитывайте данное обстоятельство при написании скриптов.

##### scans

Элемент "scans" должен содержать объект, состоящий из трёх элементов: "location", "files", "folders". Из элементов "files" и "folders" должен присутствовать хотя бы один элемент.

```json
"scans": {
	"location": "prvFile",
	"folders": [],
	"files": []
}
```

При наличии данного элемента в первый создаваемый "билд" будет встроена локация-функция, сгенерированная автоматически. Во время генерации в эту локацию будут прописаны пути ко всем существующим файлам, перечисленным в элементе "files", и ко всем файлам, которые находятся в папках, перечисленных в элементе "folders". Таким образом данная локация позволит проверять наличие того или иного файла прямо из кода вашей игры. Механизм, обеспечивающий проверку, уже встроен в эту локацию, и возвращает `1`, если файл существует, и `0` — если файл не существует.

Элемент "location" нужен, чтобы указать название локации, которое вы хотите использовать в своей игре. По-умолчанию локация будет называться "prvFile".

```json
"location": "prvFile"
```

Элемент "files" содержит непосредственно пути к файлам (в виде массива), наличие которых требуется проверять.

```json
"files": [
	"..\\example_game\\res\\img\\scl\\scale-green-leo.bmp",
	"..\\example_game\\res\\img\\scl\\scale-space-leo.bmp",
	"..\\example_game\\res\\img\\scl\\scl.rainbow.gif"
]
```

Элемент "folders" содержит непосредственно пути к папкам (в виде массива), из которых выбирается список всех файлов, наличие которых требуется проверять.

```json
"folders":[
	"..\\example_game\\res\\img\\diary",
	"..\\example_game\\res\\img\\drive",
	"..\\example_game\\res\\img\\ico",
	"..\\example_game\\res\\img\\obj"
]
```

> **Обратите внимание**, в файле "`project.json`" все пути указываются относительно его расположения, но в генерируемой локации все пути будут сгенерированы относительно файла, прописанного в элементе ["start"](#start).
> Так же обратите внимание, что если в первом "билде" отсутствует перечисление отдельных файлов в элементе "files", то сгенерированная локация-функция будет самой первой локацией в полученном билде! См. раздел ["project"](#project) и раздел ["Порядок сборки и запуска"](#порядок-сборки-и-запуска).

Пример проверки пути в QSP:

```qsp
if func('prvFile','res\img\ico\p.gif'):
	"Файл существует"
else
	"Файл не существует"
end
```

#### Пути

Элементы "start","build", "path" и другие должны содержать абсолютные или относительные пути к файлам или папкам.

Относительные пути обсчитываются относительно расположения файла "`project.json`" и записываются по следующим правилам:

1. Разделителем между папками/файлами в пути выступает обратный слэш, однако он должен быть проэкранирован дублированием:

	`"lib\\easy.dialog\\mod.qsp"`

2. Путь не должен начинаться с разделителя (двойной обратный слэш):

	так писать можно: `"lib\\easy.dialog\\mod.qsp"`

	так писать нельзя: `"\\lib\\easy.dialog\\mod.qsp"`

3. Указание на текущую папку (в которой лежит "project.json") производится через точку:

	`"."` - текущая папка

4. Допускается указание текущей папки через точку и относительный путь от этой папки:

	`".\\lib"` — вложенная в текущую папку папка "lib". Равносильно такой записи:
	`"lib"`

5. Используя две точки можно указать папку выше текущей:

	`".."` — папка, в которую вложена текущая

6. Можно указывать папки на несколько уровней вверх, указывая через двойной бэкслэш две точки для каждого уровня:

	`"..\\.."` — на два уровня выше текущей
	`"..\\..\\.."` — на три уровня выше текущей

7. Можно так же указывать папки относительно папок, расположенных выше текущей:

	`"..\\export"` — папка "export", размещённая в одном каталоге с текущей.
	`"..\\..\\project\\other_game\\lib"` — два уровня вверх, и от этой папки в "`project\other_game\lib`".

#### Пример проекта

В папке "`[disdocs]\example_project`" есть пример *разобранного* проекта. Почти все локации разнесены по отдельным файлам и разбросаны в разные папки по функционалу и тематике. Если считать "`[disdocs]\example_project`" за корень, то в корне размещён, помимо остальных папок, файл "`project.json`", который и определяет порядок сборки основного файла игры и файлов модулей.

Попробуйте сделать билд этого проекта, если сомневаетесь, что правильно поняли, как работает билдер. При сборке данного проекта в папке "`[disdocs]\example_game`" будут созданы основной файл игры "`game.sam.qsp`" и файлы различных модулей. Не забудьте прописать свой путь к плееру для правильного запуска. Если Вы используете режим **Build and Run**, файл "`game.sam.qsp`" будет запущен в плеере.

#### Порядок сборки и запуска

Для удобства определены три режима работы QBST:

* **Build and Run** — сборка и запуск. Запускается сочетанием `["ctrl+f5"]`.
* **Build** — исключительно сборка. Запускается сочетанием `["ctrl+alt+q"]`.
* **Run** — исключительно запуск. Запускается сочетанием `["ctrl+alt+s"]`.

У каждого из режимов есть свои особенности.

"**Build and Run**" отличается тем, что в этом режиме обязательно собираются заново все файлы "`.qsp`", определённые инструкциями "`project.json`", затем, если в инструкциях неверно указан, или не указан, файл "`.qsp`", который следует запустить (элемент "start"), запускается самый первый определённый инструкциями собранный файл "`.qsp`".

"**Build**" отличается тем, что в этом режиме происходит новая сборка всех файлов "`.qsp`", определённых инструкциями "`project.json`", и больше ничего.

"**Run**" — в этом режиме не производится новая сборка файлов "`.qsp`", но запускается в плеере тот файл "`.qsp`", который указан в "`project.json`" в элементе "start", либо, если файл указан неверно или не указан совсем, любой выбранный файл "`.qsp`" и открытый во вкладке Sublime Text.

При сборке содержимое файлов формата qsps добавляется в результирующий файл в следующем порядке:

1. Файлы, перечисленные в массиве элемента "files", по порядку. Таким образом самыми первыми в файле "`.qsp`" оказываются локации из самого первого файла в элементе "files".
	Данной особенностью можно воспользоваться, если вам нужно строго определить первую локацию в игре, но порядок остальных вас не волнует. Просто выносите эту локацию в отдельный текстовый файл, а расширение ставите "`.txt`", или напрмиер "`.start`", затем указываете путь к файлу самым первым в массиве элемента "files".
2. Файлы "`.qsps`", "`.qsp-txt`" и "`.txt-qsp`" содержащиеся в папках, перечисленных в массиве элемента "`folders`" по порядку, независимо от уровня вложенности. Т.е. если у нас перечисленны по порядку папки "`1`", "`2`" и "`3`", то сначала в результирующий файл добавятся локации из папки "`1`" и всех её вложенных папок, затем из папки "`2`" и всех её вложенных папок, затем из папки "`3`" и всех её вложенных папок. При этом первыми всегда добавляются файлы самого верхнего уровня, а потом с более глубоких уровней вложенности. Это особенно важно учитывать, если Вы используете препроцессор.
3. Перед конвертированием готовых файлов "`.txt`" формата qsps в "`.qsp`", если включена обработка препроцессором, такие файлы будут дополнительно обработаны встроенным в билдер препроцессором. Так же после обработки препроцессором, непосредственно перед конвертированием, будут запущены python-скрипты, пути к которым прописываются в специльном параметре ["postprocessors"](#postprocessors).

##### Упрощённый запуск

Упрощённый запуск — это запуск игры без "`project.json`", а вернее "`project.json`" при этом будет создан автоматически. Для такого запуска необходимо, чтобы плеер лежал по адресу "`C:\Program Files\QSP\qsp570\qspgui.exe`".

Тогда, если исходник игры "`.qsps`" лежит не в папке с проектом другой игры, он будет запущен, как самостоятельная игра.

Подобный запуск удобен, когда вам нужно быстро протестировать небольшой фрагмент кода, а создавать целый проект под это нет смысла: вы можете просто написать исходник, сохранить его вне любого проекта игры, и запустить одним из вышеперечисленных способов.

#### Ошибки

Начиная с версии 0.10 некритические ошибки выводятся в консоль Sublime Text. Примеры таких ошибок:

* `"main: Start-file is wrong. Don't start the player."` — эта ошибка означает, что стартовый файл не был определён. Она может возникнуть в том случае, если элемент "start" отсутствует в "`project.json`", или путь к файлу указан неверно, при этом QBST запущен в режиме "**Run**", но файл "`.qsp`" не открыт в активной вкладке.
* `"main: Path at player is wrong. Prove path '[...]'."` — эта ошибка означает, что путь к плееру указан неверно.
* `"main: Start-file is wrong. Used '[...]' for start the player."` — эта ошибка означает, что стартовый файл в элементе "start" не был определён, или он был указан неверно, поэтому после сборки всех файлов "`.qsp`" в плеере будет запущен самый первый из инструкций сборки файл "`.qsp`".
* `"main: Key 'build' not found in project-list. Choose export name [...]"` — эта ошибка означает, что не был определён элемент "build" в инструкции сборки, т.е. не предложено имя конечного файла "`.qsp`". В случае этой ошибки имя файла назначается автоматически.
* `"function.getFilesList: Folder is empty. Prove path '[...]'."` — функция *getFilesList* не смогла получить список файлов для сборки по указанному пути.
* `"function.genFilesPaths: File don't exist. Prove path '[...]'."` — функция *genFilesPaths* не обнаружила файла по указанному пути. Данный файл не существует.
* `function.searchProject: not found 'project.json' file for this project. Prove path '[...]'."` — функция *searchProject* не обнаружила файл "`project.json`".

Ошибки в консоли могут иметь похожий вид, что значит, что ошибка в работе самого плагина, или в написанном исходнике игры:

```
Traceback (most recent call last):
  File "D:\my\GameDev\QuestSoftPlayer\projects\JAD\QBST\main.py", line 72, in <module>
    qsp.constructFile(build_files,exit_txt)
  File "D:\my\GameDev\QuestSoftPlayer\projects\JAD\QBST\function.py", line 44, in constructFile
    file.write(text)
  File "C:\Program Files\Python39\lib\encodings\cp1251.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_table)[0]
UnicodeEncodeError: 'charmap' codec can't encode character '\u2191' in position 29347: character maps to <undefined>
```

В данном случае ошибка показывает, что имеются проблемы с декодированием. Сообщайте о подобных ошибках письмом на почту aleksversus@mail.ru.

**ВНИМАНИЕ!!!** Если вы столкнулись с тем, что билдер собирает вашу игру не полностью (т.е. некоторые локации не попадают в итоговую версию игры), выставьте параметр "save_txt2gam" в значение "True" и посмотрите в промежуточном текстовом файле, какая локация последней попадает в итоговую версию. Где-то с 99% вероятностью следующая за ней локация написана неправильно (например, не закрыта кавычка или фигурная скобка), исправьте эту локацию в исходниках и затем снова запустите билд. Скрипт, равно как и утилита TXT2GAM, конвертирует игру любого объёма, хоть тысяча локаций, хоть тридцать тысяч, если они написаны соответственно формату qsps.

#### Препроцессор

Препроцессор - это набор команд предобработки исходного текста программы перед компиляцией. В нашем случае, до того, как мы сконвертируем файлы проекта в конечные файлы "`.qsp`", мы можем исключить из этих файлов некоторые строки, или рекомбинировать их.

Препроцессор написан с нуля, поэтому будут баги и логические ошибки в работе команд. Я ни разу не пользовался сторонними препроцессорами, поэтому могу изобрести велосипед там, где все гоняют на Kawasaki z900. Будьте аккуратны и делайте побольше коммитов.

При препроцессинге билдер работает в несколько раз медленнее.

##### Команды (директивы, инструкции)

Для удобства в препроцессор встроены два уровня инструкций: непосредственно команды препроцессора и специальные комментарии.

Специальные комментарии (спецкомментарии):

* `!@` — комментарий, начинающийся с такого сочетания символов, будет удалён при препроцессинге.
* `!@<` — комментарий, начинающийся с такого сочетания символов, а так же строка, в которой стоит этот комментарий, будут удалены при препроцессинге.

Команды препроцессора:

* `!@pp:on` — включает препроцессинг для текущего файла. Данная команда должна идти первой или второй строкой в файле. Препроцессинг будет происходить только в режимах "On" и "Off". См. раздел [включение препроцессора](#Включение-препроцессора).
* `!@pp:off` — выключает препроцессинг для текущего файла. Данная команда должна идти первой или второй строкой в файле.
* `!@pp:savecomm` - данная команда отключает обработку специальных комментариев. Действует до конца файла, либо пока не встретится нижеследующая команда.
* `!@pp:nosavecomm` - данная команда включает обработку специальных комментариев.
* `!@pp:var(name=123)` - данная команда объявляет метку *name* со значением **"123"**. Обратите внимание: имена меток могут содержать любые символы, кроме двоеточия и пробела, поэтому допустимой может быть запись:
`!@pp:var(123=123)` - эта команда объявит метку *123* со значением **"123"**. Все объявленные значения - текстовые величины. Так же обратите внимание, что если значение и название метки совпадают, при дальнейшем препроцессинге все значения, совпадающие с названием метки, будут восприниматься препроцессором исключительно как названия метки. Более того, все значения сами по себе являются метками, содержащими одноимённые значения!
* `!@pp:if(name==123):exclude` - данная команда проверяет, выполняется ли условие в скобках (содержит ли метка *name* значение **123**), и если условие выполняется, исключает нижеследующие строки кода из конечного файла. Вместо слова `exclude` можно использовать другие ключевые слова:
	* `exclude` — исключить последующие строки из конечного файла при выполнении условия. Если условие не будет выполнено, строки будут обработаны препроцессором и включены в конечный файл.
	* `include` — последующие строки должны быть включены в конечный файл при выполнении условия, при этом строки будут обработаны препроцессором. Если условие не будет выполнено, строки не будут включены в конечный файл.
	* `nopp` — не обрабатывать строки препроцессором при выполнении условия.
	* `savecomm` — не обрабатывать специальные комментарии, как инструкции.
Можно комбинировать ключевые слова (например, `exclude nopp` и `include nopp`).
Содержимое скобок при проверке условия может содержать следующие операции:
	* `==` — проверка равны ли два значения. Верно если равны.
	* `!=` — проверка не равны ли два значения. Верно если не равны.
* `!@pp:endif` - данная команда указывает окончание блока условия.

##### Некоторые синтаксические правила

1. Все команды препроцессора являются комментариями QSP, и записываются как комментарии, то есть начиная с символа `!`.
2. Команды препроцессора всегда записываются в одну строку, без отступов от начала строки!
3. Все команды, имена меток, значения и т.д. пишутся в нижнем регистре.
4. Имена меток и их значения необходимо писать без пробелов, двоеточий и любых видов кавычек. Лучше избегать спецсимволов.
5. Использовать имена `and`, `or`, `not` для меток запрещено.
6. Допустимо объявлять метку без указания значения: `!@pp:var(layer)` — объявляет метку `layer`.
7. Специальные комментарии `!@` и `!@<` должны быть однострочными! Хотя и могут размещаться в строке с другими операторами.

##### Некоторые особенности работы препроцессора

1. При препроцессинге все команды препроцессора удаляются из конечного файла.
2. Команды препроцессора будут выполняться даже в том случае, если они размещены внутри строковых значений QSP, если записаны согласно требованиям синтаксических правил:
```qsp
*pl "Текстовое значение, разбитое на несколько строк
!@pp:if(layer):exclude
Данные строки будут исключены из конечного файла,
если метка layer была определена.
!@pp:endif
А эта строка останется в конечном файле"
```
3. Специальные комментарии не будут обрабатываться, если они размещены внутри кавычек или фигурных скобок.
4. Специальные комментарии будут обрабатываться даже если они идут в конце обычных комментариев. Чтобы отключить обработку спецкомментария в обычном комментарии, спецкомментарий можно расположить внутри кавычек или фигурных скобок.
5. Все метки и их значения являются глобальными для всего проекта! Будьте внимательны при организации препроцессинга.
6. НЕ ПОДДЕРЖИВАЕТСЯ ВЛОЖЕННОСТЬ УСЛОВИЙ. Не рекомендуется, но возможно комбинировать условия, используя ключевые слова `and` и `not`:
```qsp
!@pp:if(layer and quest_navigator):include
"Если метки layer и quest_navigator определены, данная строка останется в конечном файле"
!@pp:endif
```
7. Заранее определены метки "True" и "False", для которых установлены соответствующие булевые значения. Таким образом допустимо использовать команды `if(build_em!=True)` или `if(build_em==False)`.

##### Включение препроцессора

1. Включить препроцессор сразу для всего проекта можно, указав в "`project.json`" значение (режим "On"):
	```json
	"preprocessor":"On",
	```
	При этом абсолютно все файлы будут подвергаться препроцессингу, в т.ч. исходники модулей. Всё, что собирается проектом, будет обработано перед сборкой. Исключение составляют файлы, для которых препроцессинг отключается командой `!@pp:off`.
2. Включить препроцессор только для одного файла можно командой:
	```
	!@pp:on
	```
	Эту команду необходимо указать первой или второй строкой в обрабатываемом файле. Если препроцессор выключен выставлением режима "Hard-off", данная команда работать не будет.

##### Выключение препроцессора

1. Для всего проекта можно использовать значение в "`project.json`" (режим "Off"):
	```json
	"preprocessor":"Off",
	```
	Данное значение является значением по умолчанию, поэтому его можно не указывать. При этом файлы, поставленные в обработку командой `!@pp:on`, всё равно будут обрабатываться препроцессором.
2. Другое значение, полностью исключающее препроцессинг проекта (режим "Hard-off"):
	```json
	"preprocessor":"Hard-off",
	```
	Данное значение отключает препроцесинг абсолютно для всех файлов, даже если в файлах проставлены команды `!@pp:on`.
3. Из препроцессинга в режиме "On" исключаются файлы, содержащие команду:
	```
	!@pp:off
	```
	Эту команду необходимо указать первой или второй строкой в обрабатываемом файле.

##### Примеры

Подробный пример смотрите в файле "`[disdocs]/example_project/[pp-test]/pptest.qsps`".

```qsp
!@pp:on
!@pp:var(layer=1)
# start
"Текст, который мы увидим на локации."
!@pp:if(layer==1):include
"Этот текст будет включён в конечный файл" & !@ а этот комментарий будет удалён
"Этот текст будет удалён" & !@< вместе с комментарием, потому что препроцессор работает
!@pp:endif
!@pp:if(layer==1):exclude
"Этот текст будет исключён из конечного файла" & ! и комментарий тоже
!@pp:endif
- start
```

```qsp
!@pp:on
!@pp:var(layer=0)
# start
"Текст, который мы увидим на локации."
!@pp:if(layer==1):include
"Этот текст не будет включён в конечный файл"
!@pp:endif
!@pp:if(layer==1):exclude
"Этот текст не будет исключён из конечного файла" & ! и комментарий тоже
name=123 & !@< а вот эта строка кода будет удалена
!@pp:endif
- start
```

### Подсветка синтаксиса QSP

Если Вы установили пакет QSP согласно [инструкции](#Установка-QBST), значит у вас уже установлена и работает подсветка кода QSP.

#### Автоматическое включение подсветки QSP-кода

Подсветка автоматически включается для файлов с расширениями "`.qsps`", "`.qsp-txt`", или "`.txt-qsp`". Если Вам нужно чтобы подсветка QSP-кода автоматически включалась для файлов с другими расширениями, пропишите в начале таких файлов строку:

```QSP-Game```

После слова `Game` можно поставить пробел и добавить ещё какой либо текст, например название игры или модуля.

### Сниппеты

Сниппеты — это стандартные фрагменты кода, которые можно вставить, набрав ключевое слово, или часть строки кода, и нажав клавишу `Tab`. Переключаться между полями вставленного фрагмента также можно с помощью клавиши `Tab`.

Вот какие сниппеты вы можете использовать:

* `qspgame` вставляет заготовку файла-локации. (пока что почему-то не работает)

* `newloc` или последовательный ввод `# ` (диез и пробел) - добавляет новую локацию:
	```
	# название_локации
	!@ Код, выполняемый при посещении локации
	--- название_локации ---------------------------------
	```
* `addobj` - добавляет одну из строк кода:
	```
	addobj "Название предмета","путь к файлу картинки/picture.jpg",позиция
	addobj "Название предмета"
	```
* `act` - добавляет действие:
	```
	act "Название действия":
		!@ Код действия
	end
	```
* `if` - добавляет конструкцию условия:
	```qsp
	if условие_выполнено:
	!@ Если условие выполнено
		!@ Код, который выполняется, если условие выполнено
	end	
	```
* `ifelse` - добавляет условие с ветвлением:
	```qsp
	if условие_выполнено:
	!@ Если условие выполнено
		!@ Код, который выполняется, если условие выполнено
	else:
	!@ Если условие не выполнено
		!@ Код, который выполняется, если условие не выполнено
	end
	```
* `loop` — добавляет шаблон цикла.

Сниппеты с привязкой к клавишам. Выделяем текст и нажимаем клавиши:
* `alt+h` - Оборачивает выделенный текст в теги `<qhtml>` и `</qhtml>`
* `alt+/` - вставляет в строку сочетание `	& !@ `. Так вы можете быстрее добавлять комментарии в конце любой строки кода.

От себя могу порекомендовать сначала писать разметку в HTML-файле и затем переносить её в QSP. Это будет намного удобнее, к тому же почти все плагины, не будут действовать в QSP-коде.

### Сочетания клавиш

* `Ctrl+Alt+Q` — сборка файлов игры без запуска в плеере.
* `Ctrl+Alt+S` — запуск уже собранного файла игры в плеере без повторной сборки.
* `Ctrl+F5` — сборка файлов игры из исходников и запуск игры в плеере.
* `Ctrl+Shift+R` — запускает GOTO по проекту, при этом открывается список локаций по всему проекту, а так же меток на текущей локации.
* `Ctrl+R` — запускает GOTO по текущему файлу, при этом открывается список локаций и меток по текущему файлу.
* `Alt+H` — оборачивает выделенный текст в теги `<qhtml>` и `</qhtml>`.
* `Alt+/` — вставляет в строку сочетание `	& !@ `.
* `Ctrl+Alt+N` — открывает новое окно в редакторе с уже включённой подсветкой QSP.
* `Ctrl+/` — все выделенные строки помечаются, как однострочные комментарии.
* `Ctrl+Shift+/` — весь выделенный текст помещается в блок комментария `! { ... }`.

### Вспомогательные скрипты

Вспомогательные скрипты при установленном пакете QSP доступны из основного меню Sublime Text.

Откройте `Tools → QSP tools` для доступа к вспомогательным скриптам. Здесь вам доступны:

* `Make New Game` — данный инструмент открывает новое окно в редакторе с уже включённой подсветкой QSP. Комбинация клавиш для быстрого вызова `Ctrl+Alt+N`.
* `Make Quick Project` — создаёт новый стандартный проект QSP.
* Конвертеры одиночных файлов (`Converters (Single Files)`):
	* `Game to QSPS` — конвертирует QSP-файл игры в файл формата QSPS. Чтобы использовать конвертер, откройте файл с расширением `.qsp` в Sublime Text, и выберите данный пункт в главном меню (`Tools → QSP tools → Converters (Single Files) → Game to QSPS`).
	* `QSPS to game` — конвертирует файл формата QSPS в файл игры QSP. Чтобы использовать конвертер, откройте файл с расширением `.qsps`, `.qsp-txt` или `.txt-qsp` в Sublime Text, и выберите данный пункт в главном меню (`Tools → QSP tools → Converters (Single Files) → QSPS to game`).
* Сплиттеры (`Splitters`):
	* `Split Current File` — разделяет файл QSP, или qsps, на несколько qsps-файлов, каждый из которых будет содержать только одну локацию. Если при этом рядом лежал файл `.qproj`, локации будут разделены по папкам, соответственно информации в этом файле. Чтобы воспользоваться сплиттером, откройте файл, который хотите разбить на несколько, в Sublime Text и выберите данный пункт в главном меню (`Tools → QSP tools → Splitters → Split Current File`).
	* `Split Project` — работает так же, как и предыдущий сплиттер, только отыскивает все файлы QSP и qsps в папке с открытым файлом и разбивает их на локации. Чтобы воспользоваться данным сплиттером, откройте в Sublime Text любой файл из папки, файлы в которой вы хотите обработать, а затем выберите данную команду в главном меню (`Tools → QSP tools → Splitters → Split Project`).

### Автоподстановка

* Большая часть **ключевых слов**, когда вы начнёте их вводить, будет всплывать в контекстном меню. Вы можете выбрать вставку сниппета с ключевым словом, выделив строку с ним в контекстном меню, и нажав клавишу `Tab` или `Enter`.
* Автоматически предлагаются названия некоторых уже созданных локаций, когда вы вводите название локации в конструкции неявного вызова функции (`@foo`).
* Sublime Text сам отслеживает, собирает и предлагает автоматически названия различных переменных и ключевых слов, не реализованных в плагине.

### Другие фишки

* При установке курсора на ключевое слово, в строке статуса (статусбар) отображается справочная информация по использованию этого ключевого слова.
* При вводе названия локации, которая уже существует в проекте, всплывает сообщение с предупреждением.

## Совместная разработка и контроль версий

Для более точных сведений о совместной разработке, вам необходимо ознакомиться с системами Git, github, и иными, более подробно. Здесь приводятся лишь основные моменты, с которых могут начать новички.

### Контроль версий

Для контроля версий разрабатываемой игры необходимо установить на своём компьютере Git. Нижеследующие пункты взяты из инструкции https://htmlacademy.ru/blog/boost/frontend/git-console и ориентированы на пользователей Windows:

1. Скачиваем установщик со страницы https://git-scm.com/download/win
2. Устанавливаем программу, и при установке можем отметить или снять пункты "Windows Explorer integration":
	* "Git Bash Here" — пункт контекстного меню, который запустит косноль git bash в указанной папке
	* "Git GUI Here" — пункт контекстного меню, который запустит git с графическим интерфейсом в указанной папке
3. Ещё при установке можно выбрать редактор по умолчанию. Я выбирал Sublime Text, и если вы уже установили Sublime Text и теперь впервые устанавливаете Git, то так же выбирайте его. Остальные пункты можно оставить без изменения.
4. После установки Git можете добавить user.name и user.email для всех своих проектов через командную строку Windows или Git CMD, хотя в принципе это не обязательно. См. https://htmlacademy.ru/blog/boost/frontend/git-console
5. Для пробы можете создать новый репозиторий. Для этого:
	* создайте любую пустую папку. Например, я храню все проекты на диске `D:` в папке "`projects`", поэтому для нового репозитория я создал папку "`new_rep`" ("`D:\projects\new_rep`").
	* откройте командную строку Windows или Git CMD и перейдите в указанный каталог с помощью команды "`cd`":
		`cd "D:\projects\new_rep"`

	* инициализируйте создание нового репозитория (данная команда создаст репозиторий, даже если в папке уже есть содержимое):
		`git init`

Собственно это всё, что нужно для контроля версий. В интернете есть много информации о работе с Git, и в принципе, если вам удобно вести контроль версий, используя консоль, то вам будет достаточно Git Bash. Кое-кому удобен даже Git GUI. Однако...

#### Sublime Merge

...если вы откроете один из файлов вашего проекта (репозитория) в Sublime Text, то в строке состояния вы увидите особую отметку, которая показывает число изменённых файлов проекта. Если вы добавите новый файл в тестовый репозиторий "`new_rep`", то эта отметка будет выглядеть, как "`master|1|`" — то есть 1 изменение в master-ветке проекта.

![master-1](https://i.ibb.co/6Dghs74/image.png)

Дело в том, что Sublime Text автоматически подхватывает списки изменений из Git (условно говоря). Если вы щёлкнете по отметке об изменениях, Sublime Text предложит вам скачать Sublime Merge. Обязательно скачайте и установите, так как Sublime Merge в совокупности с Sublime Text является более удобным Git-клиентом.

По сути Git-клиент — это приложение, которое взаимодействует с системой Git, чтобы обеспечивать вам наглядное и удобное управление вашими репозиториями. Это что-то вроде внешнего GUI для Git.

Любое, или все изменения, можно закоммитить (зафиксировать в истории изменений), используя Sublime Merge. Для этого отмечаете нужные файлы и изменения в них, вводите текст коммита и нажимаете кнопку "Commit". Если вы ещё не указывали "user.name" и "user.email", Sublime Merge предложит вам сделать это.

### Совместная разработка

Теперь, когда у вас есть все инструменты для контроля версий, осталось организовать совместную разработку. Я предлагаю воспользоваться системой github, как наиболее удобным для новичков хранилищем репозиториев.

Всем разработчикам придётся зарегистрировать по одному аккаунту на github. Один из разработчиков должен создать репозиторий для совместной разработки игры. При этом можно выбрать опцию "Private" (репозиторий будет доступен для просмотра вам и выбранным людям) или "Public" (репозиторий смогут просматривать все).

Разработчик, создавший репозиторий, должен выслать приглашения остальным разработчикам. Это делается в разделе GitHub "Settings" — "Manage Access"

Когда у всех разработчиков появляется доступ к репозиторию, каждому нужно зайти в Sublime Merge открыть меню "File" - "Clone Repository", откроется вкладка, в которой нужно указать URL репозитория и другие параметры доступа, например SSH-ключ.

## Заключение

Данное руководство будет пополняться подробностями по мере возникновения вопросов. 

Если у вас есть, что спросить, пишите на aleksversus@mail.ru, помогу чем смогу, а ваши вопросы помогут улучшить текст данного руководства.

Пишите обязательно, если у вас есть советы или замечания по работе пакета, и в частности билдера, по наполнению данного руководства и иные.

## P.S.:

**Видео о работе с JAD:**
[![Работа с JAD](https://i.ibb.co/nsgpkqV/cover-blacksteel.png)](https://youtu.be/jgAnP4Hrfvk)

**Расширение Псевдопода для VS Code:** [QSP + VS Code](https://qsp.org/index.php?option=com_agora&task=topic&id=1286&Itemid=57)

* Канал на YouTube обучающий писать игры на QSP: https://www.youtube.com/c/aleksversus

* Сайт с текстовыми играми и программами для создания игр: https://qsp.org
* Наша группа в vk: https://vk.com/qsplayer
* В дискорде: https://discord.gg/bbbdxhE9M2

* [Обсуждение справочника "Как сделать? Ча.Во." на форуме](https://qsp.org/index.php?option=com_agora&task=topic&id=1280&p=1&prc=25&Itemid=57)
* [Скачать справочник на mega.nz](https://mega.nz/folder/vG4XzSoZ#gf0jU0FFdWHpgJnN8eAaGA)
* Онлайн-версия справочника (+статьи): https://aleksversus.github.io/howdo_faq/
* [Примеры кода и различные решения на mega.nz](https://mega.nz/folder/rfAllKzR#rssaaJSs4tpGA_tUbaCCQw)
* [Различные программы по QSP на mega.nz](https://mega.nz/folder/jXwXlSRJ#TF7P-soOJOWIC8MrBA-L1A)

* [Обучение HTML и CSS, плюс немного JS](https://mega.nz/folder/WXhkWLSI#WmF8uN01JeuIyopuCtGlMw)

Новые версии плеера:

* Nex (Quest Navigator): https://qsp.org/index.php?option=com_agora&task=topic&id=633&Itemid=57
* WereWolf (QSPider): https://qsp.org/index.php?option=com_agora&task=topic&id=1291&Itemid=57
* Sonnix (Плеер с поддержкой webm): https://qsp.org/index.php?option=com_agora&task=topic&id=1192&p=1&prc=25&Itemid=57#p26813
* Seedheartha (Quest Player Fork для андроид): https://qsp.org/index.php?option=com_agora&task=topic&id=128&p=10&prc=25&Itemid=57#p27855

Поблагодарите отца-основателя платформы Байта: https://qsp.org/index.php?option=com_comprofiler&Itemid=20&user=66

## Донаты

**Донаты на развитие проекта и канала на ютубе**:
* Закинуть сумму единоразово https://www.donationalerts.com/r/aleksversus
* Подписаться за 10 или 50 символических рублей (можно и бесплатно): https://boosty.to/aleksversus (на бусти я публикую различные новости, связанные с моей творческой деятельностью. Выход новых роликов на канале, статьи, отзывы, рецензии, рассказы, стихи и всё прочее по мере выхода).
* На патреоне, символическая подписка в 1 бакс https://www.patreon.com/aleksversus. К сожалению, сейчас я не имею возможности пользоваться патреоном.
