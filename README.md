# JAD for QSP

JAD — Joint Application Development,

или по-русски: Совместная Разработка Приложений. В нашем случае совместная разработка игр на QSP.

## Разработка QSP-игр в Sublime Text

### Выбор редактора, или Почему Sublime Text?

Всем новичкам в разработке игр на QSP я предлагаю начинать с Quest Generator, так как он удобен, прост и интуитивно понятен. Пишешь локации, запускаешь игру нажатием на кнопку - тестируешь.

Однако со временем выявляются разного рода недостатки, присущие Quest Generator'у. И эти недостатки подталкивают нас к поиску более удобного и функционального редактора.

В идеале нам нужен редактор, который на лету проверяет очевидные ошибки, из которого можно запустить игру прямо в плеере, и который обеспечит нам контроль версий и работу с репозиторием, например, на гитхабе.

По-идее нам подходит **VS Code**, так как это очень удобное IDE с уже встроенными инструментами для взаимодействия с системами контроля версий (по нажатию пары кнопок можно делать коммиты и отправлять их в репозиторий), но пока не доделано [расширение Псевдопода](http://qsp.su/index.php?option=com_agora&task=topic&id=1286&Itemid=57), лично для меня **VS Code** остаётся не очень удобным редактором, и я использую его разве что для проверки ошибок в различных играх.

Ещё на заре появления QSP была создана утилита [TXT2GAM](http://qsp.su/index.php?option=com_content&task=view&id=52&Itemid=56), которая позволяет разрабатывать игру в виде текстового файла (исходника) в любом текстовом редакторе, а потом конвертировать исходник в готовый файл игры. Но, к сожалению, мало какой текстовый редактор мог похвастаться адекватной [подсветкой кода QSP](http://qsp.su/index.php?option=com_agora&task=topic&id=686&Itemid=57).

Я решил остановиться на **Sublime Text**, поскольку этот редактор позволяет даже мне, не особо шарящему в программировании, написать собственную подсветку синтаксиса, имеет выход на консоль и собственный Python-интерпретатор. К тому же я давно пользуюсь данным редактором для обычной писательской деятельности, и настолько привык к нему, что уже не представляю, может ли быть что-то удобнее.

Ко всему прочему я возобновил изучение Python, одно наложилось на другое, и всё это в итоге вылилось в разработку специального скрипта, который собирает из разрозненных файлов в формате TXT2GAM обычный файл игры на QSP с расширением "`.qsp`". Также я переработал старую подсветку QSP для **Sublime Text** и теперь она гораздо более адекватно работает с файлами формата TXT2GAM.

Если Вы не знаете, как пишутся игры на QSP в формате TXT2GAM, ознакомьтесь с уроками от ELMORTEM: http://qsp.su/index.php?option=com_content&view=article&id=91&Itemid=56

Работа в **Sublime Text** по сравнению с **Quest Generator** имеет ряд преимуществ:

* **Контроль версий.** Поскольку все части игры хранятся в виде текстовых файлов (исходного кода), они легко обрабатываются системами контроля версий, например GIT. Таким образом, Вы можете проследить все этапы создания вашей игры, и быстрее находить ошибки.
* **Совместная разработка.** Вы можете организовать общий репозиторий, например на GitHub, и разрабатывать игру командой, при этом можно легко отследить, кто и какие изменения вносит в проект.
* **Удобство модульной разработки.** Вы можете одновременно в одной программе работать над всеми модулями вашей игры, или открывать для каждого модуля своё окно, или пользоваться любыми иными возможностями **Sublime Text**, а затем собрать и запустить игру, нажав всего одну комбинацию клавиш. QBST (см. раздел [**QSP-Builder for Sublime Text**](#QSP-Builder-for-Sublime-Text)) соберёт все нужные вам файлы "`.qsp`" и запустит игру в плеере по нажатию пары клавиш.
* **Один редактор - много плееров.** В специальном [файле проекта](#projectjson) можно для каждой игры указать собственный плеер. Таким образом, одну игру Вы можете разрабатывать например для **qSpider**, одну для **Quest Navigator**, а другую для **классики**. И вам не придётся ставить себе три **Quest Generator** с разными настройками для плееров. Возможно так же писать одну игру и запускать в разных плеерах, имея несколько файлов проектов, и т.д. Всё зависит от ваших нужд.
* **Sublime Text.** Sublime Text умеет подсвечивать HTML, JavaScript и CSS, что очень сильно облегчает разработку игр для **Quest Navigator** и **qSpider**. Если вам сильно не хватало проверки орфографии в **QGen**, то здесь Вы [можете себе её сделать](https://devmag.ru/sublime-text-3-spellcheck/). Поиск и замена лишь по определённым файлам и папкам (а значит и локациям)? В **Sublime Text** есть и это. Сложно придумать, что умеет **QGen** и не умеет **Sublime Text** — гораздо проще придумать, что умеет **ST** и не умеет **Quest Generator**.

### QSP-Builder for Sublime Text

QSP-Builder for Sublime Text (далее QBST, билдер) — это python-скрипт, который:

1. собирает из разрозненных файлов формата TXT2GAM файл игры в формате TXT2GAM;
2. конвертирует полученный файл в файл игры в формате "`.qsp`" (QSP-файл)
3. запускает указанный файл игры в плеере QSP

QBST принимает следующие аргументы, записанные в любом порядке и количестве:

`--b`, `--build`, `--buildandrun`, `--br` — данные аргументы разрешают непосредственно сборку QSP-файла.

`--r`, `--run`, `--buildandrun`, `--br` — данные аргументы разрешают запуск QSP-файла в плеере.

...		Если ни один из вышеуказанных аргументов не указан, считается, что был передан `--br`.

`"file.qsps"` — название любого файла, от которого высчитывается расположение "`project.json`".

Поскольку в Sublime Text скрипт запускается горячими клавишами — передаваемые ему параметры предопределены.

Возникающие ошибки для удобства помещаются в файл "`errors.log`", который может появиться либо рядом со скриптом, либо в папке с "`project.json`" в зависимости от того, в каком месте работы программы возникла ошибка.

К QBST прилагается так же пакетный файл (пакет) "`QSP.sublime-package`", необходимый для установки и корректной работы QBST.

#### Установка QBST

0. Данная инструкция ориентирована на пользователей, которые скачали последний релиз со страницы релизов: [JAV_for_QSP/releases](https://github.com/AleksVersus/JAD_for_QSP/releases). Скачайте rar-архив из последнего релиза и распакуйте в отдельную папку. В распакованном виде JAD включает в себя папку "`[disdocs]`, и её содержимое, "`QSBT`", и её содержимое, и файл "`QSP.sublime-package`", который по сути представляет собой обычный zip-архив с изменённым расширением.

1. Прежде всего у вас должен быть установлен Sublime Text, желательно Sublime Text 4. Скачать его можно отсюда https://www.sublimetext.com/download.
2. Необходимо так же установить Python 3, если он до сих пор не установлен. Конечно, Sublime Text 4 включает собственный интерепретатор python, однако рекомендую скачать и установить полную версию с официального сайта https://www.python.org/downloads/. Запишите путь к интерпретатору python, это понадобится нам в дальнейшем. Например, у меня Python расположен по этому адресу: "`C:\Program Files\Python39\python.exe`".
3. Теперь нужно скопировать папку "`QBST`" в какую-нибудь отдельную папку. Я бы предложил скопировать её куда-нибудь поближе к плееру QSP. Например, у меня установлен Quest Navigator по адресу "`C:\Program Files (x86)\QSP\Quest Navigator\QuestNavigator.exe`", поэтому я копирую папку "`QBST`" в папку "`C:\Program Files (x86)\QSP`". Не забудьте записать путь до файла "`main.py`", который лежит в папке "`QBST`" у меня он выглядит так: "`C:\Program Files (x86)\QSP\QBST\main.py`". Этот путь нам тоже понадобится для настройки билдера.
4. Следующее, что нужно сделать, это пересобрать пакет, который будет включать систему сборки QSP-файлов, подсветку синтаксиса и другие элементы для работы с файлами QSP в Sublime Text. Ничего сложного в этом нет:
	* Откройте файл "`QSP.sublime-package`" с помощью архиватора (например, WinRAR) и извлеките файлы "`QSP.sublime-build`" и "`Default.sublime-keymap`". Оба файла можно открыть с помощью Sublime Text. Закрывать "`QSP.sublime-package`" пока не нужно.
	* Откройте файл "`QSP.sublime-build`"и отредактируйте строки, содержащие путь к интерпретатору Python, указав путь к установленному на вашем компьютере интерпретатору. Т.е. замените путь "`C:\\Program Files\\Python39\\python.exe`" на ваш (четыре раза). Не забывайте экранировать бэкслэш дублированием (в разметке JSON вместо одного бэкслэша `\` ставятся два `\\`).
	* Отредактируйте строки, содержащие путь к QBST, указав путь к файлу "`main.py`". Т.е. замените путь "`С:\\Program Files (x86)\\QSP\\QBST\\main.py`" на ваш (четыре раза!). Не забывайте экранировать бэкслэш дублированием. Сохраните файл "`QSP.sublime-build`" и закройте.
	* Ознакомьтесь с горячими клавишами для сборки и запуска файлов "`.qsp`", или измените их. Для этого откройте файл "`Default.sublime-keymap`".
	* Если вам не нравятся назначенные мной сочетания клавиш, перепишите, заменив `["ctrl+f5"]`, `["ctrl+alt+q"]` и `["ctrl+alt+s"]` на иные сочетания. Сохраните и закройте файл "`Default.sublime-keymap`".
	* Теперь упакуйте оба файла "`QSP.sublime-build`" и "`Default.sublime-keymap`" обратно в "`QSP.sublime-package`" с заменой файлов и "`QSP.sublime-package`" можно закрыть.
5. Осталось только установить пакет QSP в ваш Sublime Text. Для этого просто скопируйте (или переместите) файл "`QSP.sublime-package`" в папку "`Packages`" в месте установки вашего Sublime Text. Например, у меня эта папка лежит по адресу "`C:\Program Files\Sublime Text\Packages`".

#### Порядок работы с проектом игры на QSP

1. Проект организуется по папкам. В корневой папке проекта должен лежать файл "`project.json`", который и содержит в себе инструкции по сборке проекта (см. раздел [**project.json**](#projectjson)).
2. Все рабочие файлы проекта пишутся в формате TXT2GAM и сохраняются с расширениями "`.qsps`", "`.qsp-txt`" или "`.txt-qsp`", предпочтительно указывать первое расширение. В качестве исключения можно указывать иные расширения, но в таком случае необходимо будет указывать пути до конкретных файлов (см. раздел "**project.json**"). Sublime Text по умолчанию работает с файлами кодировки UTF-8, поэтому и билдер написан под данную кодировку. Если кодировка в конечном файле игры нарушена, значит Вы работаете с исходниками в кодировке отличной от UTF-8, смените кодировку исходников на UTF-8.
3. После редактирования и сохранения файлов можно выбрать один из режимов сборки:
	* "**QSP - qsp-build**" — собрать файлы согласно инструкции и сконвертировать в "`.qsp`", по умолчанию сочетание клавиш `["ctrl+alt+q"]`.
	* "**QSP - qsp-run**" — запустить стартовый файл, указанный в проекте "`project.json`", в плеере. По умолчанию сочетание клавиш `["ctrl+alt+s"]`.
	* "**QSP**" — собрать файлы согласно инструкции и запустить стартовый файл в плеере, по умолчанию сочетание клавиш `["ctrl+f5"]`.

Для примера рассмотрим мой проект игры "*fantastic battles*", который я писал в Quest Generator.

В этом проекте пришлось разбить игру на отдельные модули для удобства разработки, и всего таких модулей получилось четыре:
* "`fb_v.0.2.qsp`" — основной файл игры, в котором подключаются все прочие файлы модулей
* "`intro.qsp`" — модуль вводных данных игры
* "`drive.qsp`" — основной движок игры
* "`bases.qsp`" — различные базы исходников для игры

Каждый из этих файлов может содержать множество локаций, поэтому для самих файлов ведутся файлы "`.qproj`", которые содержат псевдопапки. Например, в "`fb_v.0.2.qsp`" локации разбиты на псевдопапки:

-	-	"`[start]`" — стартовая локация без папки
-	"`системное меню`" — папка с локациями основного меню
	-	"`[1.0_game_start]`" — локация, запускающая игру
	-	"`[0.1_game_info]`" — локация с информацией об игре
-	"`локации места`" — папка локаций места, и собственно локации:
	-	"`[м:0]_общий_вид_локации_места`"
	-	"`[м:1]_дом`"
	-	"`[м:2]_улица`"
	-	"`место;стандартная_кухня`"
-	"`обязательные локации`" — папка стандартных локаций для этой игры
	-	"`[chest]`" — сундуки
	-	"`[death]`" — смерть
	-	"`[help]`" — помощь

Работая в редакторе типа Sublime Text, я могу не только разбить данный файл игры на отдельные файлы и разместить их по папкам, но каждую локацию писать в отдельном файле. Я могу создавать подпапки и т.д., а потом собирать те же четыре файла из разрозненных qsps-файлов.

В данном случае я бы выделил отдельную папку под каждый модуль, в том числе — под основной файл игры. Допустим так:

- "`[game]`" — папка с основным файлом игры
    - "`start.qsps`" — файл со стартовой локацией
    - "`системное меню`" — папка с локациями системного меню
        - "`sysmenu.qsps`" — обе локации системного меню в одном файле
    - "`локации места`" — папка для локаций мест, можно дополнить другими папками
        - "`стандартные места`" — папка для стандартных локаций мест
            - "`общий вид локации места.qsp-txt`" — файл с локацией "`[м:0]_общий_вид_локации_места`"
            - "`кухня.qsps`" — файл с локацией "`место;стандартная_кухня`"
		- "`дом.qsps`" — файл с локацией "`[м:1]_дом`"
		- "`улица.qsps`" — файл с локацией "`[м:2]_улица`"
	- "`обязательные локации`" — папка с файлами обязательных локаций
		- "`chests.qsps`" — файл с локацией "`[chest]`"
		- "`death and help.qsps`" — файл с локациями "`[help]`" и "`[death]`"

Необходимо отметить, что при сборке конечного файла из таких разрозненных файлов, к конечному файлу добавляются сначала локации из файлов, которые лежат в папках верхних уровней, затем файлы из папок нижних уровней. Таким образом локация из файла "`start.qsps`" окажется в самом верху списка локаций при создании файла "`.qsp`". Это особенно важно учитывать, если Вы пользуетесь возможностями препроцессора.

##### project.json

Пример с комментариями представлен в файле "`[disdocs]\example.json`".

Как видно из расширения, проект представляет собой JSON-файл. Это значит, что вся его структура состоит из JSON-объектов (в Python - это словари) и JSON-массивов (в Python - это списки). Немного более подробно о файлах формата JSON Вы можете прочитать здесь: [https://www.hostinger.ru/rukovodstva/chto-takoe-json](https://www.hostinger.ru/rukovodstva/chto-takoe-json). Пока же для краткости скажем, что JSON-объекты записываются в фигурных скобках и состоят из элементов вида ключ-значение, разделённых запятыми. Между ключом и значением обязательно ставится двоеточие, за последним элементом ни в коем случае нельзя ставить запятую. Ключ — всегда записывается с использованием кавычек, то есть это всегда строка. JSON-массивы записываются в квадратных скобках, в которых через запятую перечисляются значения. За последним значением ни в коем случае не ставится запятая. Значениями могут быть числа, строки, другие объекты и массивы.

В данном случае корневым элементом является объект, в котором присутствуют шесть элементов:

```json
"project":[]
"start":"startgame.qsp"
"converter":"C:\\Program Files\\QSP\\txt2gam.exe"
"player":"C:\\Program Files\\QSP\\Quest Navigator\\QuestNavigator.exe"
"save_txt2gam":"True"
"preprocessor":"Off"
```

Значением элемента "project" является массив однотипных объектов, в которых присутствуют следующие элементы:

```json
"build":"exitfile.qsp"
"files":[]
"folders":[]
```

Элемент "build" содержит путь к конечному файлу "`.qsp`", который мы хотим получить.

~~Элемент "top_location" содержит название локации, которая должна идти самой первой в результирующем файле. **Не используется**.~~

Элементы "files" и "folders" содержат массивы однотипных объектов. И в том и в другом случаем объекты содержат элементы "path", однако для "files" каждый элемент "path" содержит путь к конкретному файлу, из которого мы должны получить локации, а для "folders" каждый элемент "path" содержит путь к папке, и уже из этих папок выбираются файлы "`.qsps`", "`.qsp-txt`", "`.txt-qsp`".

Значением элемента "start" является путь к файлу, который необходимо запускать в плеере после билда. Это не обязательно должен быть один из собранных файлов, т.е. указать можно абсолютно любой файл "`.qsp`".

Значением элемента "converter" является путь к утилите, конвертирующей файлы формата TXT2GAM в файлы "`.qsp`".

Значением элемента "player" является путь к плееру, в котором необходимо запустить игру (например, после сборки).

- Скачать утилиту TXT2GAM можно отсюда: [QSP.su/Разработчикам/TXT2GAM](http://qsp.su/index.php?option=com_content&task=view&id=52&Itemid=56)

- Различные плееры лежат здесь: [QSP.su/Плееры](http://qsp.su/index.php?option=com_content&view=article&id=64&Itemid=87)

Элемент "save_txt2gam" разрешает оставлять промежуточные файлы после сборки. Т.е. рядом с каждым собранным файлом "`.qsp`" будет лежать его исходник в формате TXT2GAM. Ему можно назначать значения `"True"` и `"False"`. Значением по умолчанию является `"False"`.

Последний элемент "preprocessor" позволяет включать и выключать препроцессор при сборке файлов. Подробнее см. раздел [**Препроцессор**](#препроцессор). Ему можно назначать значения `"On"`, `"Off"` и `"Hard-off"`. Значением по умолчанию является `"Off"`.

##### Пути

Элементы "start","build" и "path" должны содержать абсолютные или относительные пути к файлам или папкам.

Относительные пути обсчитываются относительно расположения файла "`project.json`" и записываются по следующим правилам:

1. Разделителем между папками/файлами в пути выступает обратный слэш, однако он должен быть проэкранирован дублированием:

	`"lib\\easy.dialog\\mod.qsp"`

2. Путь не должен начинаться с разделителя (двойной обратный слэш):

	так писать можно: `"lib\\easy.dialog\\mod.qsp"`

	так писать нельзя: `"\\lib\\easy.dialog\\mod.qsp"`

3. Указание на текущую папку (в которой лежит "project.json") производится через точку:

	`"."` - текущая папка

4. Допускается указание текущей папки через точку и относительный путь от этой папки:

	`".\\lib"` — вложенная в текущую папку папка "lib". Равносильно такой записи:
	`"lib"`

5. Используя две точки можно указать папку выше текущей:

	`".."` — папка, в которую вложена текущая

6. Можно указывать папки на несколько уровней вверх, указывая через двойной бэкслэш две точки для каждого уровня:

	`"..\\.."` — на два уровня выше текущей
	`"..\\..\\.."` — на три уровня выше текущей

7. Можно так же указывать папки относительно папок, расположенных выше текущей:

	`"..\\export"` — папка "export", размещённая в одном каталоге с текущей.
	`"..\\..\\project\\other_game\\lib"` — два уровня вверх, и от этой папки в "`project\other_game\lib`".

##### Пример проекта

В папке "`[disdocs]\example_project`" присутствует пример *разобранного* проекта. Почти все локации разнесены по отдельным файлам и разбросаны в разные папки по функционалу и тематике. Если считать "`[disdocs]\example_project`" за корень, то в корне размещён, помимо остальных папок, файл "`project.json`", который и определяет порядок сборки основного файла игры и файлов модулей.

Попробуйте сделать билд этого проекта, если сомневаетесь, что правильно поняли, как работает билдер. При сборке данного проекта в папке "`[disdocs]\example_game`" будут созданы основной файл игры "`game.sam.qsp`" и файлы различных модулей. Не забудьте прописать свои пути к плееру и утилите TXT2GAM для правильной конвертации и запуска. Если Вы используете режим **Build and Run**, файл "`game.sam.qsp`" будет запущен в плеере.

#### Порядок сборки и запуска

Для удобства определены три режима работы QBST:

* **Build and Run** — сборка и запуск. Запускается сочетанием `["ctrl+f5"]`.
* **Build** — исключительно сборка. Запускается сочетанием `["ctrl+alt+q"]`.
* **Run** — исключительно запуск. Запускается сочетанием `["ctrl+alt+s"]`.

У каждого из режимов есть свои особенности.

"**Build and Run**" отличается тем, что в этом режиме обязательно собираются заново все файлы "`.qsp`", определённые инструкциями "`project.json`", затем, если в инструкциях неверно указан, или не указан, файл "`.qsp`", который следует запустить (элемент "start"), запускается самый первый определённый инструкциями собранный файл "`.qsp`".

"**Build**" отличается тем, что в этом режиме происходит новая сборка всех файлов "`.qsp`", определённых инструкциями "`project.json`", и больше ничего.

"**Run**" — в этом режиме не производится новая сборка файлов "`.qsp`", но запускается в плеере тот файл "`.qsp`", который указан в "`project.json`" в элементе "start", либо, если файл указан неверно или не указан совсем, любой выбранный файл "`.qsp`" и открытый во вкладке Sublime Text.

При сборке содержимое файлов формата TXT2GAM добавляется в результирующий файл в следующем порядке:

1. Файлы, перечисленные в массиве элемента "files", по порядку. Таким образом самыми первыми в файле "`.qsp`" оказываются локации из самого первого файла в элементе "files".
	
	Данной особенностью можно воспользоваться, если вам нужно строго определить первую локацию в игре, но порядок остальных вас не волнует. Просто выносите эту локацию в отдельный текстовый файл, а расширение ставите "`.txt`", или напрмиер "`.start`", затем указываете путь к файлу самым первым в массиве элемента "files".

2. Файлы "`.qsps`", "`.qsp-txt`" и "`.txt-qsp`" содержащиеся в папках, перечисленных в массиве элемента "`folders`" по порядку, независимо от уровня вложенности. Т.е. если у нас перечисленны по порядку папки "`1`", "`2`" и "`3`", то сначала в результирующий файл добавятся локации из папки "`1`" и всех её вложенных папок, затем из папки "`2`" и всех её вложенных папок, затем из папки "`3`" и всех её вложенных папок. При этом первыми всегда добавляются файлы самого верхнего уровня, а потом с более глубоких уровней вложенности. Это особенно важно учитывать, если Вы используете препроцессор.

#### Ошибки

Я решил отказаться от вывода ошибок в консоль, все они выводятся в файл "`errors.log`":

* `"main: Start-file is wrong. Don't start the player."` — эта ошибка означает, что стартовый файл не был определён. Она может возникнуть в том случае, если элемент "start" отсутствует в "`project.json`", или путь к файлу указан неверно, при этом QBST запущен в режиме "**Run**", но файл "`.qsp`" не открыт в активной вкладке.
* `"main: Path at player is wrong. Prove path '[...]'."` — эта ошибка означает, что путь к плееру указан неверно.
* `"main: Start-file is wrong. Used '[...]' for start the player."` — эта ошибка означает, что стартовый файл в элементе "start" не был определён, или он был указан неверно, поэтому после сборки всех файлов "`.qsp`" в плеере будет запущен самый первый из инструкций сборки файл "`.qsp`".
* `"main: Key 'build' not found in project-list. Choose export name [...]"` — эта ошибка означает, что не был определён элемент "build" в инструкции сборки, т.е. не предложено имя конечного файла "`.qsp`". В случае этой ошибки имя файла назначается автоматически.
* `"function.getFilesList: Folder is empty. Prove path '[...]'."` — функция *getFilesList* не смогла получить список файлов для сборки по указанному пути.
* `"function.genFilesPaths: File don't exist. Prove path '[...]'."` — функция *genFilesPaths* не обнаружила файла по указанному пути. Данный файл не существует.
* `function.searchProject: not found 'project.json' file for this project. Prove path '[...]'."` — функция *searchProject* не обнаружила файл "`project.json`".

Если всё же в консоли у вас выводятся ошибки, то скорее всего они имеют вот такой вид:

```
Traceback (most recent call last):
  File "D:\my\GameDev\QuestSoftPlayer\projects\JAD\QBST\main.py", line 72, in <module>
    qsp.constructFile(build_files,exit_txt)
  File "D:\my\GameDev\QuestSoftPlayer\projects\JAD\QBST\function.py", line 44, in constructFile
    file.write(text)
  File "C:\Program Files\Python39\lib\encodings\cp1251.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_table)[0]
UnicodeEncodeError: 'charmap' codec can't encode character '\u2191' in position 29347: character maps to <undefined>
```

В данном случае ошибка показывает, что имеются проблемы с декодированием. Сообщайте о подобных ошибках письмом на почту aleksversus@mail.ru.

#### Кодировка

Непосредственно сами файлы QSP ("`.qsp`") имеют кодировку **utf-16le**, тогда как билдер работает исключительно с файлами в кодировке **utf-8** (без BOM-символов). Чтобы билдер собирал игру правильно, исключительно важно, чтобы все файлы вашего проекта имели кодировку **utf-8**. Будьте аккуратны при использовании спецсимволов, проверяйте соответствие в исходном и конечном файле.

#### Препроцессор

Препроцессор - это набор команд предобработки исходного текста программы перед компиляцией. В нашем случае, до того, как мы сконвертируем файлы проекта в конечные файлы "`.qsp`", мы можем исключить из этих файлов некоторые строки, или рекомбинировать их.

Препроцессор написан с нуля, поэтому будут баги и логические ошибки в работе команд. Я ни разу не пользовался сторонними препроцессорами, поэтому могу изобрести велосипед там, где все гоняют на Kawasaki z900. Будьте аккуратны и делайте побольше коммитов.

При препроцессинге билдер работает в несколько раз медленнее.

##### Команды (директивы, инструкции)

Для удобства в препроцессор встроены два уровня инструкций: непосредственно команды препроцессора и специальные комментарии.

Специальные комментарии (спецкомментарии):

* `!@` — комментарий, начинающийся с такого сочетания символов, будет удалён при препроцессинге.
* `!@<` — комментарий, начинающийся с такого сочетания символов, а так же строка, в которой стоит этот комментарий, будут удалены при препроцессинге.

Команды препроцессора:

* `!@pp:on` — включает препроцессинг для текущего файла. Данная команда должна идти первой или второй строкой в файле. Препроцессинг будет происходить только в режимах "On" и "Off". См. раздел [включение препроцессора](#Включение-препроцессора).
* `!@pp:off` — выключает препроцессинг для текущего файла. Данная команда должна идти первой или второй строкой в файле.
* `!@pp:savecomm` - данная команда отключает обработку специальных комментариев. Действует до конца файла, либо пока не встретится нижеследующая команда.
* `!@pp:nosavecomm` - данная команда включает обработку специальных комментариев.
* `!@pp:var(name=123)` - данная команда объявляет метку *name* со значением **"123"**. Обратите внимание: имена меток могут содержать любые символы, кроме двоеточия и пробела, поэтому допустимой может быть запись:
`!@pp:var(123=123)` - эта команда объявит метку *123* со значением **"123"**. Все объявленные значения - текстовые величины. Так же обратите внимание, что если значение и название метки совпадают, при дальнейшем препроцессинге все значения, совпадающие с названием метки, будут восприниматься препроцессором исключительно как названия метки. Более того, все значения сами по себе являются метками, содержащими одноимённые значения!
* `!@pp:if(name==123):exclude` - данная команда проверяет, выполняется ли условие в скобках (содержит ли метка *name* значение **123**), и если условие выполняется, исключает нижеследующие строки кода из конечного файла. Вместо слова `exclude` можно использовать другие ключевые слова:
	* `exclude` — исключить последующие строки из конечного файла при выполнении условия. Если условие не будет выполнено, строки будут обработаны препроцессором и включены в конечный файл.
	* `include` — последующие строки должны быть включены в конечный файл при выполнении условия, при этом строки будут обработаны препроцессором. Если условие не будет выполнено, строки не будут включены в конечный файл.
	* `nopp` — не обрабатывать строки препроцессором при выполнении условия.
	* `savecomm` — не обрабатывать специальные комментарии, как инструкции.
Можно комбинировать ключевые слова (например, `exclude nopp` и `include nopp`).
Содержимое скобок при проверке условия может содержать следующие операции:
	* `==` — проверка равны ли два значения. Верно если равны.
	* `!=` — проверка не равны ли два значения. Верно если не равны.
* `!@pp:endif` - данная команда указывает окончание блока условия.

##### Некоторые синтаксические правила

1. Все команды препроцессора являются комментариями QSP, и записываются как комментарии, то есть начиная с символа `!`.
2. Команды препроцессора всегда записываются в одну строку, без отступов от начала строки!
3. Все команды, имена меток, значения и т.д. пишутся в нижнем регистре.
4. Имена меток и их значения необходимо писать без пробелов, двоеточий и любых видов кавычек. Лучше избегать спецсимволов.
5. Использовать имена `and`, `or`, `not` для меток запрещено.
6. Допустимо объявлять метку без указания значения: `!@pp:var(layer)` — объявляет метку `layer`.
7. Специальные комментарии `!@` и `!@<` должны быть однострочными! Хотя и могут размещаться в строке с другими операторами.

##### Некоторые особенности работы препроцессора

1. При препроцессинге все команды препроцессора удаляются из конечного файла.
2. Команды препроцессора будут выполняться даже в том случае, если они размещены внутри строковых значений QSP, если записаны согласно требованиям синтаксических правил:
```qsp
*pl "Текстовое значение, разбитое на несколько строк
!@pp:if(layer):exclude
Данные строки будут исключены из конечного файла,
если метка layer была определена.
!@pp:endif
А эта строка останется в конечном файле"
```
3. Специальные комментарии не будут обрабатываться, если они размещены внутри кавычек или фигурных скобок.
4. Специальные комментарии будут обрабатываться даже если они идут в конце обычных комментариев. Чтобы отключить обработку спецкомментария в обычном комментарии, спецкомментарий можно расположить внутри кавычек или фигурных скобок.
5. Все метки и их значения являются глобальными для всего проекта! Будьте внимательны при организации препроцессинга.
6. НЕ ПОДДЕРЖИВАЕТСЯ ВЛОЖЕННОСТЬ УСЛОВИЙ. Не рекомендуется, но возможно комбинировать условия, используя ключевые слова `and` и `not`:
```qsp
!@pp:if(layer and quest_navigator):include
"Если метки layer и quest_navigator определены, данная строка останется в конечном файле"
!@pp:endif
```
7. Заранее определены метки "True" и "False", для которых установлены соответствующие булевые значения. Таким образом допустимо использовать команды `if(build_em!=True)` или `if(build_em==False)`.

##### Включение препроцессора

1. Включить препроцессор сразу для всего проекта можно, указав в "`project.json`" значение (режим "On"):
	```json
	"preprocessor":"On",
	```
	При этом абсолютно все файлы будут подвергаться препроцессингу, в т.ч. исходники модулей. Всё, что собирается проектом, будет обработано перед сборкой. Исключение составляют файлы, для которых препроцессинг отключается командой `!@pp:off`.
2. Включить препроцессор только для одного файла можно командой:
	```
	!@pp:on
	```
	Эту команду необходимо указать первой или второй строкой в обрабатываемом файле. Если препроцессор выключен выставлением режима "Hard-off", данная команда работать не будет.

##### Выключение препроцессора

1. Для всего проекта можно использовать значение в "`project.json`" (режим "Off"):
	```json
	"preprocessor":"Off",
	```
	Данное значение является значением по умолчанию, поэтому его можно не указывать. При этом файлы, поставленные в обработку командой `!@pp:on`, всё равно будут обрабатываться препроцессором.
2. Другое значение, полностью исключающее препроцессинг проекта (режим "Hard-off"):
	```json
	"preprocessor":"Hard-off",
	```
	Данное значение отключает препроцесинг абсолютно для всех файлов, даже если в файлах проставлены команды `!@pp:on`.
3. Из препроцессинга в режиме "On" исключаются файлы, содержащие команду:
	```
	!@pp:off
	```
	Эту команду необходимо указать первой или второй строкой в обрабатываемом файле.

##### Примеры

Подробный пример смотрите в файле "`[disdocs]/example_project/[pp-test]/pptest.qsps`".

```qsp
!@pp:on
!@pp:var(layer=1)
# start
"Текст, который мы увидим на локации."
!@pp:if(layer==1):include
"Этот текст будет включён в конечный файл" & !@ а этот комментарий будет удалён
"Этот текст будет удалён" & !@< вместе с комментарием, потому что препроцессор работает
!@pp:endif
!@pp:if(layer==1):exclude
"Этот текст будет исключён из конечного файла" & ! и комментарий тоже
!@pp:endif
- start
```

```qsp
!@pp:on
!@pp:var(layer=0)
# start
"Текст, который мы увидим на локации."
!@pp:if(layer==1):include
"Этот текст не будет включён в конечный файл"
!@pp:endif
!@pp:if(layer==1):exclude
"Этот текст не будет исключён из конечного файла" & ! и комментарий тоже
name=123 & !@< а вот эта строка кода будет удалена
!@pp:endif
- start
```

### Подсветка синтаксиса QSP

Если Вы установили пакет QSP согласно [инструкции по установке QBST](#Установка-QBST) в Sublime Text, значит у вас уже установлена и работает подсветка кода QSP.

Подсветку синтаксиса я ещё буду перерабатывать, поскольку сейчас в ней не учтены многие особенности кода QSP, а так же различных цветовых схем Sublime Text. Более-менее сносно подсветка будет работать в цветовой схеме "Monokai".

#### Что умеет подсветка синтаксиса сейчас

1. Текст между локациями подсвечивается таким же цветом, как комментарий, но ведёт себя, как код. К нему применяется scope meta.diff. Это сделано для того, чтобы работали сниппеты вставки локаций.
2. Распознавание начала и конца локации и соответственно подсветка этих элементов.
3. Подсветка сложных многострочных комментариев.
4. Подсветка строковых констант.
5. Подсветка числовых констант, системных переменных, операторов и функций.
6. Подсветка вложенных выражений (подвыражений) в строках.
7. Подсветка основных синтаксических ошибок:
	* Лишний `$` перед именами числовых системных переменных или функций.
	* Отсутствие `$` перед именами текстовых системынх переменных и функций.
	* Звёздочка `*` перед именем операторов, кроме `*pl`, `*p`, `*nl`, `*clr`.
	* Неверное число операндов у операций типа `+`, `-`, `*`, `<`, `>` и т.д.
	* Подсветка неправильных имён переменных типа `123build`.
	* Разрыв строки кода внутри вложенного выражения.
	* Подсветка лишнего `end`, а так же `else` и `elseif` вне конструкций условий.
	* Подсветка неправильной записи `else` и `elseif` в многострочном условий.
	* Незакрытый многострочный `act` или `if` вызывает подсветку элемента "конец локации", как ошибки.
8. Подсветка HTML-кода в фигурных скобках и строках при вставке тегов `<html>`, `</html>`.
9. Подсветка конструкций неявного вызова, а так же подсветка ошибочной записи таких конструкций.
10. Подсветка команд препроцессора
11. Подсветка операторов многострочных конструкций `act`, `if`, `else`, `elseif`, `loop`, `end` - они подсвечиваются голубым курсивом в теме "Monokai". Правильная подсветка `end loop`, `end act`, `end if` - такие сочетания подсвечиваются, как отдельное ключевое слово.

#### Автоматический включение подсветки QSP-кода

Подсветка автоматически включается для файлов с расширениями "`.qsps`", "`.qsp-txt`", или "`.txt-qsp`". Если Вам нужно чтобы подсветка QSP-кода автоматически включалась для файлов с другими расширениями, пропишите в начале таких файлов строку:

```QSP-Game```

После слова `Game` можно поставить пробел и добавить ещё какой либо текст, например название игры или модуля.

### Сниппеты и поведения

#### Сниппеты

Сниппеты — это стандартные фрагменты кода, которые можно вставить, набрав ключевое слово, или часть строки кода, и нажав клавишу `Tab`. Переключаться между полями вставленного фрагмента так же можно с помощью клавиши `Tab`.

Вот какие сниппеты вы можете использовать:

* `newloc` или последовательный ввод `# ` (диез и пробел) - добавляет новую локацию:
	```
	# название_локации
	!@ Код, выполняемый при посещении локации
	--- название_локации ---------------------------------
	```
	(диез пробел может не работать. Пока не понятно, почему)
* `addobj` - добавляет одну из строк кода:
	```
	addobj "Название предмета","путь к файлу картинки/picture.jpg",позиция
	addobj "Название предмета"
	```
* `act` - добавляет действие:
	```
	act "Название действия":
		!@ Код действия
	end
	```
* `if` - добавляет конструкцию условия:
	```qsp
	if условие_выполнено:
	!@ Если условие выполнено
		!@ Код, который выполняется, если условие выполнено
	end	
	```
* `ifelse` - добавляет условие с ветвлением:
	```qsp
	if условие_выполнено:
	!@ Если условие выполнено
		!@ Код, который выполняется, если условие выполнено
	else:
	!@ Если условие не выполнено
		!@ Код, который выполняется, если условие не выполнено
	end
	```
Сниппеты HTML-разметки с привязкой к клавишам. Выделяем текст и нажимаем клавиши:
* `b` - Оборачивает выделенный текст в теги `<b>` и `</b>`
* `i` - Оборачивает выделенный текст в теги `<i>` и `</i>`
* `p` - Оборачивает выделенный текст в теги `<p>` и `</p>`
* `f` - Оборачивает выделенный текст в теги `<font color=#000000 size=0>` и `</font>`
* `d` - Оборачивает выделенный текст в теги `<div>` и `</div>`
* `h` - Оборачивает выделенный текст в теги `<h1>`-`<h6>` и `</h1>`-`</h6>`
* `alt+h` - Оборачивает выделенный текст в теги `<html>` и `</html>`

#### Поведения

Слвом "Поведения" я так криво перевёл умение Sublime Text автоматически подставлять нужные наборы символов в различных ситуациях.

Если пишешь `act`, `loop`, `if` и т.п., затем после двоеточия нажимаешь `Enter`, в следующей строке автоматически добавляется отступ. Если после этого вводишь `end`, отступ перед `end` сокращается. Чтобы отключить такое поведение, из "`QSP.sublime-package`" нужно удалить файл "`Indentation Rules.tmPreferences`".

Сочетание `Ctrl+Shift+R` запускает GOTO по проекту, при этом открывается список локаций по всему проекту, а так же меток на текущей локации.

Сочетание `Ctrl+R` запускает GOTO по текущему файлу, при этом открывается список локаций и меток по текущему файлу.

### Вспомогательные скрипты

* `spliter.py` — скрипт, который позволяет на основе файла QSP-проекта "`.qproj`" разбить большой файл в формате TXT2GAM на отдельные файлы, каждый из которых содержит отдельную локацию. При этом все файлы размещаются в папках, как указано в файле QSP-проекта, т.е. размещение аналогично размещению по папкам в Quest Generator.

## Совместная разработка и контроль версий

Для более подробных сведений о совместной разработке, вам необходимо ознакомиться с системами Git, github, и иными, более подробно. Здесь приводятся лишь основные моменты, с которых могут начать новички.

### Контроль версий

Для контроля версий разрабатываемой игры необходимо установить на своём компьютере Git. Нижеследующие пункты взяты из инструкции https://htmlacademy.ru/blog/boost/frontend/git-console и ориентированы на пользователей Windows:

1. Скачиваем установщик со страницы https://git-scm.com/download/win
2. Устанавливаем программу, и при установке можем отметить или снять пункты "Windows Explorer integration":
	* "Git Bash Here" — пункт контекстного меню, который запустит косноль git bash в указанной папке
	* "Git GUI Here" — пункт контекстного меню, который запустит git с графическим интерфейсом в указанной папке
3. Ещё при установке можно выбрать редактор по умолчанию. Я выбирал Sublime Text, и если вы уже установили Sublime Text и теперь впервые устанавливаете Git, то так же выбирайте его. Остальные пункты можно оставить без изменения.
4. После установки Git можете добавить user.name и user.email для всех своих проектов через командную строку Windows или Git CMD, хотя в принципе это не обязательно. См. https://htmlacademy.ru/blog/boost/frontend/git-console

5. Для пробы можете создать новый репозиторий. Для этого:
	* создайте любую пустую папку. Например, я храню все проекты на диске `D:` в папке "`projects`", поэтому для нового репозитория я создал папку "`new_rep`" ("`D:\projects\new_rep`").
	* откройте командную строку Windows или Git CMD и перейдите в указанный каталог с помощью команды "`cd`":
		`cd "D:\projects\new_rep"`

	* инициализируйте создание нового репозитория (данная команда создаст репозиторий, даже если в папке уже есть содержимое):
		`git init`

Собственно это всё, что нужно для контроля версий. В интернете есть много информации о работе с Git, и в принципе, если вам удобно вести контроль версий, используя консоль, то вам будет достаточно Git Bash. Кое-кому удобен даже Git GUI. Однако...

#### Sublime Merge

...если вы откроете один из файлов вашего проекта (репозитория) в Sublime Text, то в строке состояния вы увидите особую отметку, которая показывает число изменённых файлов проекта. Если вы добавите новый файл в тестовый репозиторий "`new_rep`", то эта отметка будет выглядеть, как "`master|1|`" — то есть 1 изменение в master-ветке проекта.

![master-1](https://i.ibb.co/6Dghs74/image.png)

Дело в том, что Sublime Text автоматически подхватывает списки изменений из Git (условно говоря). Если вы щёлкнете по отметке об изменениях, Sublime Text предложит вам скачать Sublime Merge. Обязательно скачайте и установите, так как Sublime Merge в совокупности с Sublime Text является более удобным Git-клиентом.

По сути Git-клиент — это приложение, которое взаимодействует с системой Git, чтобы обеспечивать вам наглядное и удобное управление вашими репозиториями. Это что-то вроде внешнего GUI для Git.

Любое, или все изменения, можно закоммитить (зафиксировать в истории изменений), используя Sublime Merge. Для этого отмечаете нужные файлы и изменения в них, вводите текст коммита и нажимаете кнопку "Commit". Если вы ещё не указывали "user.name" и "user.email", Sublime Merge предложит вам сделать это.

### Совместная разработка

Теперь, когда у вас есть все инструменты для контроля версий, осталось организовать совместную разработку. Я предлагаю воспользоваться системой github, как наиболее удобным для новичков хранилищем репозиториев.

Всем разработчикам придётся зарегистрировать по одному аккаунту на github. Один из разработчиков должен создать репозиторий для совместной разработки игры. При этом можно выбрать опцию "Private" (репозиторий будет доступен для просмотра вам и выбранным людям) или "Public" (репозиторий смогут просматривать все).

Разработчик, создавший репозиторий, должен выслать приглашения остальным разработчикам. Это делается в разделе GitHub "Settings" — "Manage Access"

Когда у всех разработчиков появляется доступ к репозиторию, каждому нужно зайти в Sublime Merge открыть меню "File" - "Clone Repository", откроется вкладка, в которой нужно указать URL репозитория и другие параметры доступа, например SSH-ключ.

## Заключение

Данное руководство будет пополняться подробностями по мере возникновения вопросов. На самом деле тема Совместной разработки слишком обширна, чтобы осветить её здесь хоть сколько-нибудь подробно. Я и сам не вполне разобрался со многими вопросами. Но, если у вас есть, что спросить, пишите на aleksversus@mail.ru, помогу чем смогу, а ваши вопросы помогут улучшить текст данного руководства.

Пишите обязательно, если у вас есть советы или замечания по работе QBST, по наполнению данного руководства и иные.

## P.S.:

[![Работа с JAD](https://i9.ytimg.com/vi/jgAnP4Hrfvk/maxresdefault.jpg?time=1645015500000&sqp=CMzjs5AG&rs=AOn4CLBdfYk38B614-krpWKQBWnr6ZqQCg)](https://youtu.be/jgAnP4Hrfvk)

* Канал на YouTube обучающий писать игры на QSP: https://www.youtube.com/c/aleksversus

* Сайт с текстовыми играми и программами для создания игр: http://qsp.su
* Наша группа в vk: https://vk.com/qsplayer
* В дискорде https://discord.gg/SMvzEFm

* Обсуждение справочника "Как сделать? Ча.Во." на форуме http://qsp.su/index.php?option=com_agora&task=topic&id=1280&p=1&prc=25&Itemid=57
* Скачать справочник на mega.nz: https://mega.nz/folder/vG4XzSoZ#gf0jU0FFdWHpgJnN8eAaGA
* Примеры кода и различные решения: https://mega.nz/folder/rfAllKzR#rssaaJSs4tpGA_tUbaCCQw
* Программы: https://mega.nz/folder/jXwXlSRJ#TF7P-soOJOWIC8MrBA-L1A

* Обучение HTML и CSS, плюс немного JS https://mega.nz/folder/WXhkWLSI#WmF8uN01JeuIyopuCtGlMw

Новые версии плеера:

* Nex (Quest Navigator): http://qsp.su/index.php?option=com_agora&task=topic&id=633&Itemid=57
* WereWolf (QSPider): http://qsp.su/index.php?option=com_agora&task=topic&id=1291&Itemid=57
* Sonnix (Плеер с поддержкой webm): http://qsp.su/index.php?option=com_agora&task=topic&id=1192&p=1&prc=25&Itemid=57#p26813
* Seedheartha (Quest Player Fork): http://qsp.su/index.php?option=com_agora&task=topic&id=128&p=10&prc=25&Itemid=57#p27855

Поблагодарите отца-основателя платформы Байта: http://qsp.su/index.php?option=com_comprofiler&Itemid=20&user=66

А так же простимулируйте разработку нового QGen от Rrock: http://qsp.su/index.php?option=com_agora&task=topic&id=594&Itemid=57

Анонс шикарнейшей игры от Svartbergа на классическом плеере: http://qsp.su/index.php?option=com_agora&task=topic&id=1235&Itemid=57

Донаты мне на развитие проекта и канала на ютубе:
* Закинуть сумму единоразово https://www.donationalerts.com/r/aleksversus
* Подписаться на 10 рублей в месяц https://boosty.to/aleksversus (на бусти я публикую различные новости, связанные с моей творческой деятельностью. Выход новых роликов на канале, статьи, отзывы, рецензии, рассказы, стихи и сё прочее по мере выхода).
* На патреоне, символическая подписка в 1 бакс https://www.patreon.com/aleksversus
